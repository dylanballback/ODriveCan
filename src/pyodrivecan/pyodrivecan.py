from .odrivedatabase import OdriveDatabase
import asyncio
import can
import struct
import time
import subprocess




class ODriveCAN:
    """
    A class for setting up O-Drive motor controllers using CAN communication with Python on a Raspberry Pi with the Waveshare RS485 CAN HAT.

    Attributes:
        canBusID           (str): The CAN Bus ID, which should be "can0" by default. If multiple CAN buses are present on the device, this can be modified accordingly.
        canBusType         (str): The CAN communication type as defined by the python-can package. By default, "socketcan" is used.
        self.canBitRate    (int): The CAN Bit Rate or Bus Speed, by Default O-Drive GUI has this set to 250000 bits/s
        nodeID             (int): The node ID of the O-Drive controller on the CAN network.
        position           (float, optional): The current position of the motor in revolutions. Defaults to None.
        velocity           (float, optional): The current velocity of the motor in revolutions per second. Defaults to None.
        torque_target      (float, optional): The target torque for the motor. Defaults to None.
        torque_estimate    (float, optional): The estimated torque of the motor. Defaults to None.
        bus_voltage        (float, optional): The current bus voltage of the O-Drive. Defaults to None.
        bus_current        (float, optional): The current bus current of the O-Drive. Defaults to None.
        iq_setpoint        (float, optional): The setpoint current in the q-axis of the motor's dq frame. Defaults to None.
        iq_measured        (float, optional): The measured current in the q-axis of the motor's dq frame. Defaults to None.
        electrical_power   (float, optional): The calculated electrical power being delivered to the motor. Defaults to None.
        mechanical_power   (float, optional): The calculated mechanical power being produced by the motor. Defaults to None.
        error_messages     (str, optional): Any error messages that are generated by the O-Drive. Defaults to None.
        database           (str): The path to the database file used for storing O-Drive data. Defaults to 'odrive_data.db'.
        running            (bool): A flag indicating if the main event loop is running.
        active_error       (list of str): The current active error/s of the O-Drive will be added to this list. 
        disarm_reason      (list of str): The last error/s that occured on the O-Drive to cause it to disarm will be added to this list. 
                                          (Once the O-Drive is disarmed, the active error will be none and you will have to check this.) 

    Methods:
        initCanBus():            Initializes the CAN bus connection.
        flush_can_buffer():      Clears all messages from the CAN bus.
        bus_shutdown():          Shuts down the CAN bus safely.
        setAxisState():          Sets the state of the O-Drive axis.
        set_controller_mode():   Sets the control and input modes of the O-Drive.
        estop():                 Triggers an emergency stop.
        clear_errors():          Clears any errors and optionally flashes the status LED.
        set_absolute_position(): Sets the motor to an absolute position.
        set_position():          Sets the desired position for the motor.
        set_velocity():          Sets the desired velocity for the motor.
        set_torque():            Sets the desired torque for the motor.
        process_can_message():   Processes incoming CAN messages and updates the object's state.
        recv_all():              Asynchronously receives all messages from the CAN bus.
        save_data():             Asynchronously saves data to the database.
        get_velocity():          Returns the current velocity of the motor.
        run():                   Starts the main event loop for the class.
        
    Example Usage:
        # Create an instance of the ODriveCAN class (by default axis_state_name is closed_loop_control)
        odrive = ODriveCAN(nodeID=0x01)

        # Initialize CAN bus
        odrive.initCanBus()

        #Set O-Drive to position control
        odrive.set_controller_mode("position_control")

        # Set motor to a specific position
        odrive.set_position(100.0)

        #Set O-Drive to velocity control
        odrive.set_controller_mode("velocity_control")

        # Set motor velocity
        odrive.set_velocity(1.0)
        
        #Set O-Drive to torque control
        odrive.set_controller_mode("torque_control")

        # Set motor torque
        odrive.set_torque(0.1)

        # Issue an emergency stop command
        odrive.estop()

        # Clear errors on the O-Drive
        odrive.clear_errors()

        # Set the motor to an absolute position for the new default encoder "zero" postion to the current position.
        odrive.set_absolute_position()

        # Start the asynchronous event loop
        odrive.run()
    """
    # Class variable to track CAN bus setup status
    can_setup_done = False

    def __init__(
            self,
            nodeID,
            canBusID="can0",
            canBusType="socketcan",
            canBitRate=250000,
            position=None,
            velocity=None,
            torque_target=None,
            torque_estimate=None,
            bus_voltage=None,
            bus_current=None,
            iq_setpoint=None,
            iq_measured=None,
            electrical_power=None,
            mechanical_power=None,
            error_messages = None,
            database='odrive_data.db',
            active_error = None,
            disarm_reason = None
            ):
    
        self.canBusID = canBusID
        self.canBusType = canBusType
        self.canBitRate = canBitRate
        self.nodeID = nodeID
        self.canBus = can.interface.Bus(canBusID, bustype=canBusType)
        self.database = OdriveDatabase(database)
        self.collected_data = []  # Initialize an empty list to store data
        self.start_time = time.time()  # Capture the start time when the object is initialized
        self.latest_data = {}
        self.running = True
        #O-Drive Data
        self.position = position
        self.velocity = velocity
        self.torque_target = torque_target
        self.torque_estimate = torque_estimate
        self.bus_voltage = bus_voltage
        self.bus_current = bus_current
        self.iq_setpoint = iq_setpoint
        self.iq_measured = iq_measured
        self.electrical_power = electrical_power
        self.mechanical_power = mechanical_power
        self.error_messages = error_messages
        self.active_error = active_error
        self.disarm_reason = disarm_reason
        #At the start of initalizeding the oject it will automatically check if the CAN Interface on the pi is set up correctly.
        # Check if the CAN setup is already done by any instance
        if not ODriveCAN.can_setup_done:
            self.setup_can_interface()
            time.sleep(1)
            # The CAN setup will be attempted by setup_can_interface
        else:
            print("CAN bus setup already completed by another instance.")


#----------------------------- CAN Bus Setup for Raspberry Pi START -----------------------------------------
    def try_candump(self):
        """
        Attempts to verify the operational status of the CAN interface by dumping CAN messages using the `candump` command. 
        This method checks if the specified CAN interface is receiving messages, which indicates it is correctly configured and operational.

        The `candump` command is part of the Linux CAN (SocketCAN) tools and is utilized here to listen on the specified CAN interface for incoming messages, printing them to the standard output. 
        The successful capture and printing of messages serve as confirmation that the CAN interface is active and capable of participating in CAN communication.

        Parameters:
        - `self.canBusID`: Specifies the CAN interface to listen to (e.g., `can0`). The interface ID is set based on the object's `canBusID` attribute, allowing dynamic selection of the CAN interface.

        The method executes `candump` with these options:
        - `-xct z`: Formats the output by including extra message details (`-x`), enabling color output (which is ignored here due to capture in text form) (`-c`), and using zero-based timestamps for each message (`-t z`).
        - `-n 10`: Limits the output to the first 10 messages detected on the CAN bus. This constraint ensures a quick verification of interface activity without indefinitely waiting for messages.

        Returns:
        - `bool`: True if the CAN interface is confirmed operational by capturing at least one message. 
                False is returned if the `candump` command fails, times out, or does not capture any messages, suggesting the interface may not be properly configured or operational.

        Note:
        The method initially aimed to verify the capture of at least 10 messages as an indication of operational status. 
        However, it has been adjusted to consider the interface operational if at least one message is captured, reflecting a more lenient and practical approach to verifying interface activity.
        """
        dump_command = ["candump", self.canBusID, "-xct", "z", "-n", "10"]
        try:
            dump_output = subprocess.run(dump_command, check=True, capture_output=True, text=True, timeout=5)
            print(dump_output)
            lines = dump_output.stdout.splitlines()
            if len(lines) > 0:
                print("CAN interface is operational. Captured messages:")
                for line in lines:
                    print(line)
                ODriveCAN.can_setup_done = True #Set can setup flag true so another instance doesn't run this again.
                return True
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            print(f"CAN interface might not be operational or `candump` command failed. Error: {e}")
        return False

    def setup_can_interface(self):
        """
        Attempts to set up the CAN interface only if it's not already operational and will reset and restart if necessary.

        This method first checks if the CAN interface is operational by attempting to dump CAN messages.
        If messages are successfully dumped, indicating the interface is operational, the method exits without making changes.
        If the interface is already in use or encounters an error, the method attempts to reset and restart the interface before trying the setup again. 
        After a successful setup, it verifies the operational status of the interface by capturing CAN messages.

        The method executes several commands to configure the CAN interface:
        
        1. Setup Command:
            - `sudo ip link set can0 up type can bitrate 250000`: This command configures the CAN interface `can0` with a specified bitrate (250000 bits per second in this example). 
            It sets the interface type to CAN and brings it up, making it ready for communication.
        
        2. Reset Command:
            - `sudo /sbin/ip link set can0 down`: This command brings the CAN interface `can0` down, effectively resetting its configuration. 
            This is useful for clearing any existing state before attempting to reconfigure the interface.
        
        3. Restart Command:
            - `sudo ip link set can0 type can restart-ms 100`: After resetting, this command sets the interface to automatically restart in case of errors, with a restart delay specified by `restart-ms` (100 milliseconds in this case). 
            This helps in recovering from transient errors without manual intervention.
        
        If the initial setup attempt detects the interface as "busy," indicating it's already in use or cannot be configured as requested, the method performs a reset followed by a restart command before attempting the setup again. 
        This ensures that any lingering issues are cleared and the interface is correctly configured for CAN communication.

        After successfully configuring the interface, the method verifies the setup by attempting to capture CAN messages, ensuring the interface is fully operational and ready for use.

        Raises:
            Exception: If the setup process fails after retrying, including after a reset and restart attempt.
        """
        

        # Commands for setting up, resetting, and restarting the CAN interface
        setup_command = ["sudo", "ip", "link", "set", self.canBusID, "up", "type", "can", "bitrate", str(self.canBitRate)]
        reset_command = ["sudo", "/sbin/ip", "link", "set", self.canBusID, "down"]
        restart_command = ["sudo", "ip", "link", "set", self.canBusID, "type", "can", "restart-ms", "100"]
        # Command to dump CAN messages for verification
       
        
        try:
            # First, check if the CAN interface is already operational.
            if self.try_candump():
                print(f"CAN interface {self.canBusID} is already operational. Skipping setup.")
                return  # Exit the method early if CAN interface is operational.
            # Attempt to set up the CAN interface
            subprocess.run(setup_command, check=True, stderr=subprocess.PIPE, text=True)
            print("CAN interface setup successfully.")
            # Mark the setup as done to prevent future attempts within this instance
            ODriveCAN.can_setup_done = True  # Set can setup flag true so another instance doesn't run this again.
        except subprocess.CalledProcessError as e:
            if "Device or resource busy" in e.stderr:
                print("Device or resource busy, attempting to reset and restart...")
                # Reset and restart the CAN interface
                subprocess.run(reset_command, check=True)
                time.sleep(2)
                subprocess.run(restart_command, check=True)
                print("CAN interface restart attempted. Retrying setup...")
                time.sleep(2)
                # Retry the setup command
                subprocess.run(setup_command, check=True)
                # Verify setup with candump again
                if self.try_candump():
                    ODriveCAN.can_setup_done = True  # Again, set flag true only after successful verification
                    print("CAN setup verified successfully after reset and restart.")
                else:
                    raise Exception("Failed to verify CAN setup after reset and restart.")
            else:
                print(f"Error setting up CAN interface: {e.stderr}")
                raise


#----------------------------- CAN Bus Setup for Raspberry Pi END -----------------------------------------


    
    def initCanBus(self):
        """
        Initalize connection to CAN Bus

        canBusID (String): Default "can0" this is the name of the can interface
        canBus (String): Default "socketcan" this is the python can libary CAN type

        This will first clear all the buffer messages on the CAN bus, then it will set the axis state to the default "closed_loop_control"
        """
         # Create and assign the CAN bus interface object to self.canBus
        self.canBus = can.interface.Bus(self.canBusID, bustype=self.canBusType)

        #Set Axis State
        self.setAxisState()
        

    def flush_can_buffer(self):
        """
        Flushes the CAN receive buffer to clear any pending messages.

        Example:
            >>> odrive_can.flush_can_buffer()
            ...
            ... CAN BUS Flushed.
        """
        #Flush CAN RX buffer to ensure no old pending messages.
        while not (self.canBus.recv(timeout=0) is None): pass
        print("CAN BUS Flushed.")


    #Shutdown can bus at the end of a program. 
    def bus_shutdown(self):
        """
        Run this method at the end of your program to shundown the can bus to prevent can errors.

        Example:
        >>> import pyodrivecan
        >>> odrivecan.bus_shutdown()
        ...
        ... Can bus successfully shut down.
        """

        self.canBus.shutdown()

        print("Can bus successfully shut down.")


#-------------------------------------- Set Axis State ------------------------------------------------
    def setAxisState(self, axis_state_name = "closed_loop_control"):
        """
        Sets the Axis State of an ODrive Controller through CAN Bus using a human-readable state name.
        After sending the set state command, it listens for a heartbeat message to confirm the state change.

        Parameters:
            axis_state_name (str): The desired state to set for the axis, specified as a text string corresponding to the state names.
            axis_state_name    (str): The default axis state to which the O-Drive should be set. Defaults to "closed_loop_control".

        Supported Axis States:
            - "undefined"
            - "idle"
            - "startup_sequence"
            - "full_calibration_sequence"
            - "motor_calibration"
            - "encoder_index_search"
            - "encoder_offset_calibration"
            - "closed_loop_control"
            - "lockin_spin"
            - "encoder_dir_find"
            - "Homing"
            - "encoder_hall_polarity_calibration"
            - "encoder_hall_phase_calibration"
            - "anticogging_calibration"

        Example:
            # Set the ODrive axis to Closed Loop Control
            >>> odrive_can.setAxisState("closed_loop_control")
        """
        # Mapping from state names to their corresponding codes
        state_codes = {
            "undefined": 0,
            "idle": 1,
            "startup_sequence": 2,
            "full_calibration_sequence": 3,
            "motor_calibration": 4,
            "encoder_index_search": 6,
            "encoder_offset_calibration": 7,
            "closed_loop_control": 8,
            "lockin_spin": 9,
            "encoder_dir_find": 10,
            "homing": 11,
            "encoder_hall_polarity_calibration": 12,
            "encoder_hall_phase_calibration": 13,
            "anticogging_calibration": 14
        }

        # Reverse mapping from codes to state names for reporting purposes
        state_names = {code: name for name, code in state_codes.items()}

        if axis_state_name not in state_codes:
            print(f"Unsupported axis state: {axis_state_name}. Please check the state name.")
            return

        axis_requested_state = state_codes[axis_state_name]

        try:
            self.flush_can_buffer() #Flush all current can bus messages
            # Send the set state command with a timeout
            self.canBus.send(
                can.Message(
                    arbitration_id=(self.nodeID << 5 | 0x07),  # 0x07: Set_Axis_State command ID
                    data=struct.pack('<B', axis_requested_state),
                    is_extended_id=False
                ),
                timeout=0.5  # Timeout of 0.5 seconds
            )
            print(f"Axis state set command sent for {axis_state_name} ({axis_requested_state}) to ODrive {self.nodeID}.")
            
            # Now we wait for a heartbeat message to confirm the new state
            #print(f"Waiting for confirmation from ODrive {self.nodeID}...")
            start_time = time.time()
            while time.time() - start_time < 5:  # Wait for up to 5 seconds for confirmation
                msg = self.canBus.recv(timeout=0.5)  # Adjust timeout as needed
                if msg and (msg.arbitration_id == (self.nodeID << 5 | 0x01)):  # 0x01: Heartbeat
                    _, state, _, _ = struct.unpack('<IBBB', bytes(msg.data[:7]))
                    if state == axis_requested_state:
                        print(f"Confirmation received: ODrive {self.nodeID} is now in state {axis_state_name}.")
                        return
                    else:
                        # Retrieve the actual state name from the code
                        actual_state_name = state_names.get(state, "Unknown State")
                        print(f"ODrive {self.nodeID} did not enter {axis_state_name}. It is currently in {actual_state_name}.")
                        return
                elif msg:
                    continue # Skip any non-heartbeat messages
                else:
                    # If no message is received within the timeout, print an error message
                    print(f"No confirmation received from ODrive {self.nodeID}. Please check the device.")
                    return

        except Exception as e:
            print(f"Error setting axis state for ODrive {self.nodeID}: {str(e)}")


#----------------------------------------- Check Axis State Idle --------------------------------------------------------
            
    def is_odrive_idle(self):
        """
        Checks if the ODrive is in the IDLE state.

        Returns:
            bool: True if the ODrive is in the IDLE state, False otherwise.
        """
        state_names = {
            0: "undefined",
            1: "idle",
            2: "startup_sequence",
            3: "full_calibration_sequence",
            4: "motor_calibration",
            6: "encoder_index_search",
            7: "encoder_offset_calibration",
            8: "closed_loop_control",
            9: "lockin_spin",
            10: "encoder_dir_find",
            11: "homing",
            12: "encoder_hall_polarity_calibration",
            13: "encoder_hall_phase_calibration",
            14: "anticogging_calibration"
        }
        idle_state_code = 1  # The code for the IDLE state

        # Send a command to request the current state, or just wait for the next heartbeat message
        print(f"Checking if ODrive {self.nodeID} is in IDLE state...")
        start_time = time.time()
        while time.time() - start_time < 5:  # Wait for up to 5 seconds for a heartbeat message
            msg = self.canBus.recv(timeout=0.5)  # Adjust timeout as needed
            if msg and (msg.arbitration_id == (self.nodeID << 5 | 0x01)):  # 0x01: Heartbeat
                _, state, _, _ = struct.unpack('<IBBB', bytes(msg.data[:7]))
                if state == idle_state_code:
                    print(f"ODrive {self.nodeID} is in IDLE state.")
                    return True
                else:
                    actual_state_name = state_names.get(state, "Unknown State")
                    print(f"ODrive {self.nodeID} is in {actual_state_name} state.")
                    return False
            elif msg:
                continue  # Skip any non-heartbeat messages

        print(f"No state information received from ODrive {self.nodeID}.")
        return False


#----------------------------------------- Set Controller Mode --------------------------------------------------------

    def set_controller_mode(self, control_mode_name, input_mode_name="pass_through"):
            """
            Sets the control mode and input mode of the ODrive controller using descriptive names.

            Control Modes:
                - "voltage_control": Direct voltage control.
                - "torque_control": Torque control mode.
                - "velocity_control": Velocity control mode.
                - "position_control": Position control mode.

            Input Modes:
                - "inactive": No input, motor remains idle.
                - "pass_through": Directly pass the setpoint to the control mode.
                - "vel_ramp": Ramp the velocity setpoint over time.
                - "pos_filter": Filter the position setpoint.
                - "mix_channels": Mix multiple control inputs.
                - "trap_traj": Trapezoidal trajectory control.
                - "torque_ramp": Ramp the torque setpoint over time.
                - "mirror": Mirror the control from another axis.
                - "tuning": Input mode for controller tuning.

            Parameters:
                control_mode_name (str): The control mode to set on the ODrive, specified by name.
                input_mode_name (str): The input mode to set on the ODrive, specified by name. Default is "pass_through".

            Example:
                # Set the ODrive to use torque control and passthrough input is set by default
                >>> odrive_can.set_controller_mode(control_mode_name="torque_control")
                ...
                ... Controller mode set to torque_control and input mode set to pass_through for ODrive #nodeID.

                # Set the ODrive to use velocity control and velocity ramp input
                >>> odrive_can.set_controller_mode(control_mode_name="velocity_control", input_mode_name="vel_ramp")
                ...
                ... Controller mode set to velocity_control and input mode set to vel_ramp for ODrive #nodeID.
            """
            # Mapping of control mode names to their corresponding codes
            control_modes = {
                "voltage_control": 0x00,
                "torque_control": 0x01,
                "velocity_control": 0x02,
                "position_control": 0x03
            }

            # Mapping of input mode names to their corresponding codes
            input_modes = {
                "inactive": 0x00,
                "pass_through": 0x01,
                "vel_ramp": 0x02,
                "pos_filter": 0x03,
                "mix_channels": 0x04,
                "trap_traj": 0x05,
                "torque_ramp": 0x06,
                "mirror": 0x07,
                "tuning": 0x08
            }

            # Translate names to codes
            control_mode = control_modes.get(control_mode_name.lower())
            input_mode = input_modes.get(input_mode_name.lower())

            if control_mode is None or input_mode is None:
                print(f"Invalid control_mode_name '{control_mode_name}' or input_mode_name '{input_mode_name}'.")
                return

            try:
                # Construct the data payload by packing the control_mode and input_mode into bytes
                data_payload = struct.pack('<II', control_mode, input_mode)

                # Send the CAN message
                self.canBus.send(can.Message(
                    arbitration_id=(self.nodeID << 5 | 0x0b),  # 0x0b: Set_Controller_Mode command ID
                    data=data_payload,
                    is_extended_id=False
                ))
                print(f"Controller mode set to {control_mode_name} and input mode set to {input_mode_name} for ODrive {self.nodeID}.")
            except Exception as e:
                print(f"Error sending Set_Controller_Mode command to ODrive {self.nodeID}: {str(e)}")


#-------------------------------------- E-Stop ------------------------------------------------
    def estop(self):
        """
        Triggers an emergency stop on the ODrive motor. This command disarms the axis and sets its state to ESTOP_REQUESTED.

        Example:
            >>> odrive_can.estop()
            ...
            ... Estop requested for ODrive #NodeID.
        """
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x02),  # 0x02: Estop Command ID
                data=b'',  # Empty payload as specified
                is_extended_id=False
            ))
            print(f"Estop requested for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending Estop command to ODrive {self.nodeID}: {str(e)}")



#-------------------------------------- Clear Errors ------------------------------------------------
    def clear_errors(self, identify=True):
        """
        Sends a command to the ODrive to clear errors and optionally flash the status LED for identification.

        Parameters:
            identify (bool): If True, the status LED will flash to help identify the ODrive device. This is useful in a setup with multiple devices.

        Example:
            # Clear errors and flash the LED to identify the ODrive
            >>> odrive_can.clear_errors()
            ... 
            ... Cleared errors for ODrive NodeID. LED flash is enabled.
            
            # Clear errors without flashing the LED and flash the LED to identify the ODrive
            >>> odrive_can.clear_errors(identify=False)
            ...
            ... Cleared errors for ODrive NodeID. LED flash is disabled.

        Note: The LED flash helps to physically identify which ODrive is being addressed in a multi-device setup.
        """
        identify_byte = 0x01 if identify else 0x00
        try:
            self.canBus.send(
                can.Message(
                    arbitration_id=(self.nodeID << 5 | 0x18),  # 0x18: Clear_Errors Command ID
                    data=struct.pack('<B', identify_byte),
                    is_extended_id=False
                ),
                timeout=0.5 
            )
            print(f"Cleared errors for ODrive {self.nodeID}. LED flash is {'enabled' if identify else 'disabled'}.")
        except Exception as e:
            print(f"Error sending Clear_Errors command to ODrive {self.nodeID}: {str(e)}")


#-------------------------------------- Reboot O-Drive  ------------------------------------------------

    def reboot_save(self, action='save'):
        """
        Reboots the ODrive or performs related actions based on the specified action parameter.

        Parameters:
            action (str): The action to be performed, which can be one of the following:
                        'reboot': Reboot the ODrive.
                        'save': Save the configuration to persistent storage.
                        'erase': Erase the configuration.
                        'dfu': Enter DFU (Device Firmware Upgrade) mode.

        Command ID: 0x16 (Host â†’ ODrive)

        Note: The axis must be in the IDLE state before performing this action.
        """
        actions = {
            'reboot': 0,
            'save': 1,
            'erase': 2,
            'dfu': 3
        }

        if action not in actions:
            print(f"Invalid action specified: {action}. Must be one of {list(actions.keys())}.")
            return

        # Check if ODrive is in IDLE state before proceeding
        if not self.is_odrive_idle():
            print(f"ODrive {self.nodeID} is not in IDLE state. Cannot perform {action} action.")
            return

        command_id = 0x16  # Command ID for reboot actions
        action_byte = actions[action]
        message_data = struct.pack('<B', action_byte)

        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | command_id),
                data=message_data,
                is_extended_id=False
            ))
            print(f"{action.capitalize()} command sent to ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending {action} command to ODrive {self.nodeID}: {str(e)}")



#-------------------------------------- Set Absoulte Postion  ------------------------------------------------
    def set_absolute_position(self, position=None):
        """
        Sends a command to the ODrive to set the motor to an absolute position. If no position is specified,
        the motor will be set to the last known position.

        Parameters:
            position (float, optional): The new position for the motor in revolutions. If None, the last known position will be used.

        Example:
            # Set the motor to an absolute position of 10 revolutions
            >>> odrive_can.set_absolute_position(10.0)

            # Set the motor to the last known position
            >>> odrive_can.set_absolute_position()
        """
        # Use the latest known position if none is provided
        if position is None:
            position = self.position
            if position is None:
                print("No position specified and no known last position. Command aborted.")
                return

        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x19),  # 0x19: Set_Absolute_Position Command ID
                data=struct.pack('<f', position),  # Pack the position as a float32
                is_extended_id=False
            ))
            print(f"Set absolute position to {position} revolutions for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending Set_Absolute_Position command to ODrive {self.nodeID}: {str(e)}")




#-------------------------------------- Motor Trajectory Limits START------------------------------------------------
    def set_traj_vel_limit(self, vel_limit):
        """
        Sets the trajectory velocity limit for the ODrive motor.

        Parameters:
            vel_limit (float): The desired trajectory velocity limit in revolutions per second (rev/s).

        Example:
            >>> odrive_can.set_traj_vel_limit(1000.0)
        """
        data_bytes = struct.pack('<f', vel_limit)
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x11),  # Command ID for Set_Traj_Vel_Limit is 0x11
                data=data_bytes,
                is_extended_id=False
            ))
            print(f"Trajectory velocity limit set to {vel_limit} rev/s for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending trajectory velocity limit command to ODrive {self.nodeID}: {str(e)}")



    def set_traj_accel_limits(self, accel_limit, decel_limit):
        """
        Sets the trajectory acceleration and deceleration limits for the ODrive motor.

        Parameters:
            accel_limit (float): The desired trajectory acceleration limit in revolutions per second squared (rev/s^2).
            decel_limit (float): The desired trajectory deceleration limit in revolutions per second squared (rev/s^2).

        Example:
            >>> odrive_can.set_traj_accel_limits(5000.0, 5000.0)
        """
        data_bytes = struct.pack('<ff', accel_limit, decel_limit)
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x12),  # Command ID for Set_Traj_Accel_Limits is 0x12
                data=data_bytes,
                is_extended_id=False
            ))
            print(f"Trajectory acceleration limit set to {accel_limit} rev/s^2 and deceleration limit set to {decel_limit} rev/s^2 for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending trajectory acceleration/deceleration limits command to ODrive {self.nodeID}: {str(e)}")


    def set_traj_inertia(self, inertia):
        """
        Sets the trajectory inertia for the ODrive motor.

        Parameters:
            inertia (float): The desired trajectory inertia in Nm/(rev/s^2).

        Example:
            >>> odrive_can.set_traj_inertia(0.1)
        """
        data_bytes = struct.pack('<f', inertia)
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x13),  # Command ID for Set_Traj_Inertia is 0x13
                data=data_bytes,
                is_extended_id=False
            ))
            print(f"Trajectory inertia set to {inertia} Nm/(rev/s^2) for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending trajectory inertia command to ODrive {self.nodeID}: {str(e)}")



    def set_limits(self, velocity_limit, current_limit):
        """
        Sets the velocity and current limits for the ODrive motor.

        Parameters:
            velocity_limit (float): The desired velocity limit in revolutions per second (rev/s).
            current_limit (float): The desired current limit in Amperes (A).

        Example:
            >>> odrive_can.set_limits(1000.0, 10.0)
        """
        data_bytes = struct.pack('<ff', velocity_limit, current_limit)
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x0f),  # Command ID for Set_Limits is 0x0f
                data=data_bytes,
                is_extended_id=False
            ))
            print(f"Velocity limit set to {velocity_limit} rev/s and current limit set to {current_limit} A for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending limits command to ODrive {self.nodeID}: {str(e)}")







#-------------------------------------- Motor Controls START------------------------------------------------
    # Function to set position for a specific O-Drive
    def set_position(self, position, velocity_feedforward=0, torque_feedforward=0):
        """
        Sets the position of the ODrive motor.

        Para:
            position (float): Target position for the motor in Revs.
            velocity_feedforward (float): Feedforward velocity, default is 0.
            torque_feedforward (float): Feedforward torque, default is 0.

        Example:
            >>> odrive_can.set_position(1000.0)
        """

        self.canBus.send(can.Message(
            arbitration_id=(self.nodeID << 5 | 0x0C),
            data=struct.pack('<fhh', float(position), velocity_feedforward, torque_feedforward),
            is_extended_id=False
        ))
        #print(f"Successfully moved ODrive {self.nodeID} to {position}")
        

    # Function to set velocity for a specific O-Drive
    def set_velocity(self, velocity, torque_feedforward=0.0):
        """
        Sets the velocity of the ODrive motor.

        Para:
            velocity (float): Target velocity for the motor in Rev/sec.
            torque_feedforward (float): Feedforward torque, default is 0.

        Example:
            >>> odrive_can.set_velocity(2.0)
        """

        self.canBus.send(can.Message(
            arbitration_id=(self.nodeID << 5 | 0x0d),  # 0x0d: Set_Input_Vel
            data=struct.pack('<ff', velocity, torque_feedforward),
            is_extended_id=False
        ))


    # Function to set torque for a specific O-Drive
    def set_torque(self, torque):
        """
        Sets the torque of the ODrive motor.

        Para:
            torque (float): Target torque for the motor in Nm.

        Example:
            >>> odrive_can.set_torque(0.1)
        """
        
        self.canBus.send(can.Message(
            arbitration_id=(self.nodeID << 5 | 0x0E),  # 0x0E: Set_Input_Torque
            data=struct.pack('<f', torque),
            is_extended_id=False
        ))
        #print(f"Successfully set ODrive {self.nodeID} to {torque} [Nm]")
#-------------------------------------- Motor Controls END-------------------------------------------------




#-------------------------------------- Motor Feedback ----------------------------------------------------
# In order for these functions to work you need to have the O-Drive set with the Cyclic messages 
# The cyclic messgaes for CAN will make the O-Drive automatically send the data you want to collect at the set rate.


    ERROR_CODES = {
        0x00: "NONE",
        0x01: "INITIALIZING",
        0x02: "SYSTEM_LEVEL",
        0x04: "TIMING_ERROR",
        0x08: "MISSING_ESTIMATE",
        0x10: "BAD_CONFIG",
        0x20: "DRV_FAULT",
        0x40: "MISSING_INPUT",
        0x80: "SPINOUT_DETECTED",
        0x100: "DC_BUS_OVER_VOLTAGE",
        0x200: "DC_BUS_UNDER_VOLTAGE",
        0x400: "DC_BUS_OVER_CURRENT",
        0x800: "DC_BUS_OVER_REGEN_CURRENT",
        0x1000: "CURRENT_LIMIT_VIOLATION",
        0x2000: "MOTOR_OVER_TEMP",
        0x4000: "INVERTER_OVER_TEMP",
        0x8000: "VELOCITY_LIMIT_VIOLATION",
        0x10000: "POSITION_LIMIT_VIOLATION",
        0x2000000: "ESTOP_REQUESTED",
        0x4000000: "SPINOUT_DETECTED",
        0x8000000: "BRAKE_RESISTOR_DISARMED",
        0x10000000: "THERMISTOR_DISCONNECTED",
        0x40000000: "CALIBRATION_ERROR",
        0x1000000: "WATCHDOG_TIMER_EXPIRED"
    }
        

    def process_can_message(self, message):
        """
        Processes received CAN messages and updates the latest data.
        """
        
        arbitration_id = message.arbitration_id
        data = message.data
        if arbitration_id == (self.nodeID << 5 | 0x09):  # Encoder estimate
            position, velocity = struct.unpack('<ff', data)
            self.position = position
            self.velocity = velocity
            #print(f"Encoder Estimate - Position: {position:.3f} turns, Velocity: {velocity:.3f} turns/s")
        elif arbitration_id == (self.nodeID << 5 | 0x1C):  # Torque
            torque_target, torque_estimate = struct.unpack('<ff', data)
            self.torque_target = torque_target
            self.torque_estimate = torque_estimate
            #print(f"Torque - Target: {torque_target:.3f} Nm, Estimate: {torque_estimate:.3f} Nm")
        elif arbitration_id == (self.nodeID << 5 | 0x17):  # Bus voltage and current
            bus_voltage, bus_current = struct.unpack('<ff', data)
            self.bus_voltage = bus_voltage
            self.bus_current = bus_current
            #print(f"Bus Voltage and Current - Voltage: {bus_voltage:.3f} V, Current: {bus_current:.3f} A")
        elif arbitration_id == (self.nodeID << 5 | 0x14):  # IQ setpoint and measured
            iq_setpoint, iq_measured = struct.unpack('<ff', data)
            self.iq_setpoint = iq_setpoint
            self.iq_measured = iq_measured
            #print(f"IQ Setpoint and Measured - Setpoint: {iq_setpoint:.3f} A, Measured: {iq_measured:.3f} A")
        elif arbitration_id == (self.nodeID << 5 | 0x1D):  # Powers
            electrical_power, mechanical_power = struct.unpack('<ff', data)
            self.electrical_power = electrical_power
            self.mechanical_power = mechanical_power
            #print(f"Powers - Electrical: {electrical_power:.3f} W, Mechanical: {mechanical_power:.3f} W")
        elif arbitration_id == (self.nodeID << 5 | 0x03):  # Get_Error message
            active_errors, disarm_reason = struct.unpack('<II', data)
            # Decode and print active errors
            if active_errors != 0:  # Check if there are any active errors
                errors = [description for code, description in self.ERROR_CODES.items() if active_errors & code]
                self.active_error = ', '.join(errors)
                print(f"ODrive {self.nodeID} Active Errors: {self.active_error}")
                #Do I want to set self.running to flase here so it will stop datacollection loop running? 
            else:
                #print(f"ODrive {self.nodeID} No active errors.")
                pass
            
            # Decode and print disarm reason
            if disarm_reason != 0:  # Check if there is a disarm reason
                reasons = [description for code, description in self.ERROR_CODES.items() if disarm_reason & code]
                self.disarm_reason = ', '.join(reasons)
                print(f"ODrive {self.nodeID} Disarm Reason: {self.disarm_reason}")
                #Do I want to set self.running to flase here so it will stop datacollection loop running? 
            else:
                #print(f"ODrive {self.nodeID} No disarm reason.")
                pass


    #This is aysnc receiving the messages from the can bus and feeding them into the process_can_message method.
    async def recv_all(self):
        while self.running:
            await asyncio.sleep(0)
            msg = self.canBus.recv(timeout=0)
            if msg is not None:
                self.process_can_message(msg)


    
    #This is aysnc saving the data to a database at a set rate (timeout=0.1) every 0.1 seconds.
    async def save_data(self, timeout=0.1):
        # Fetch the next trial_id
        next_trial_id = self.database.get_next_trial_id()
        print(f"Using trial_id: {next_trial_id}")
        node_id = self.nodeID
        while self.running:
            await asyncio.sleep(timeout)
            # Calculate elapsed time since the start of the program
            current_time = time.time() - self.start_time
            self.database.add_odrive_data(
                next_trial_id,
                node_id,
                current_time,
                self.position,
                self.velocity,
                self.torque_target,
                self.torque_estimate,
                self.bus_voltage,
                self.bus_current,
                self.iq_setpoint,
                self.iq_measured,
                self.electrical_power,
                self.mechanical_power
            )


    async def get_velocity(self):
        """
        This function makes sure that the returned velocity is not 'None'
        """
        while self.running and self.velocity is None:
            await asyncio.sleep(0)
        return self.velocity


    #This is the async loop that runs the receve_msgs and save_data methods async.
    #Use when you only have Muiltiple Instance Of ODriveCAN Class
    async def loop(self, *others):
        """
        Asynchronously runs the main event loop for the ODriveCAN class.

        This method gathers and runs multiple asynchronous tasks concurrently it is designed to be use when you have muiltiple objects. 
        Where each object continuously receive CAN messages and save data to the database while also executing any
        additional asynchronous tasks passed to it.

        Parameters:
            others (tuple): Additional coroutine functions to be run concurrently with the main
                            tasks of receiving CAN messages and saving data. These coroutines could
                            include custom logic like a PID controller or other async function you would
                            would need to concurrently run while still collecting & storing O-Drive Data.

        The primary tasks that run in the event loop are:
            - `self.recv_all()`: An asynchronous method that continuously receives and processes CAN
                                 messages from the ODrive device.
            - `self.save_data()`: An asynchronous method that periodically saves the received data
                                  to the configured database.

        Usage:
            When you have muiltiple objects of the ODriveCAN Class and you want to run them all concurrently.
            Below is an example on how to have 2 objects `odrive1`, `odrive2`, and a custom async function `async_user_PID_control_func`
            Using the await asyncio.gather() will receive & collect all data for Odrive1 and Odrive2 concurrently while also running the users
            custom ayncio function like a pid controller which you would want to run concurrently. 

        Example:
            >>> await asyncio.gather(odrive1.loop(), odrive2.loop(), async_user_PID_control_func())
            ...
        
        """
        await asyncio.gather(
            self.recv_all(),
            self.save_data(),
            *others,
        )


    #Use when you only have Single Instance Of ODriveCAN Class
    def run(self, *others):
        """
        Starts the main event loop for the ODriveCAN class using asyncio.

        This method serves as the entry point to begin asynchronous operations for the ODriveCAN
        class. It initializes and runs the main event loop by calling the `loop` method and passing
        any additional coroutines specified by the caller.

        This method is only really useful when you have a single instance of the class. 

        Parameters:
            others (tuple): Additional coroutine functions to be run concurrently with the main
                            event loop. These are passed directly to the `loop` method.

        Usage:
            To start the ODriveCAN operations along with any custom asynchronous tasks, call this
            method with the tasks as arguments. For example:

                odrive_can_instance.run(custom_task1(), custom_task2())

            This will start the main event loop and run `custom_task1` and `custom_task2` concurrently
            with the default tasks of receiving CAN messages and saving data.
        """
        asyncio.run(self.loop(*others))

