from .odrivedatabase import OdriveDatabase
import asyncio
import can
import struct
import time




class ODriveCAN:
    """
    A class for setting up O-Drive motor controllers using CAN communication with Python on a Raspberry Pi with the Waveshare RS485 CAN HAT.

    Attributes:
        canBusID           (str): The CAN Bus ID, which should be "can0" by default. If multiple CAN buses are present on the device, this can be modified accordingly.
        canBusType         (str): The CAN communication type as defined by the python-can package. By default, "socketcan" is used.
        nodeID             (int): The node ID of the O-Drive controller on the CAN network.
        position           (float, optional): The current position of the motor in revolutions. Defaults to None.
        velocity           (float, optional): The current velocity of the motor in revolutions per second. Defaults to None.
        torque_target      (float, optional): The target torque for the motor. Defaults to None.
        torque_estimate    (float, optional): The estimated torque of the motor. Defaults to None.
        bus_voltage        (float, optional): The current bus voltage of the O-Drive. Defaults to None.
        bus_current        (float, optional): The current bus current of the O-Drive. Defaults to None.
        iq_setpoint        (float, optional): The setpoint current in the q-axis of the motor's dq frame. Defaults to None.
        iq_measured        (float, optional): The measured current in the q-axis of the motor's dq frame. Defaults to None.
        electrical_power   (float, optional): The calculated electrical power being delivered to the motor. Defaults to None.
        mechanical_power   (float, optional): The calculated mechanical power being produced by the motor. Defaults to None.
        error_messages     (str, optional): Any error messages that are generated by the O-Drive. Defaults to None.
        database           (str): The path to the database file used for storing O-Drive data. Defaults to 'odrive_data.db'.
        axis_state_name    (str): The default axis state to which the O-Drive should be set. Defaults to "closed_loop_control".
        running            (bool): A flag indicating if the main event loop is running.

    Methods:
        initCanBus():            Initializes the CAN bus connection.
        flush_can_buffer():      Clears all messages from the CAN bus.
        closed_loop_control():   Sets the O-Drive to closed-loop control mode.
        bus_shutdown():          Shuts down the CAN bus safely.
        setAxisState():          Sets the state of the O-Drive axis.
        set_controller_mode():   Sets the control and input modes of the O-Drive.
        estop():                 Triggers an emergency stop.
        clear_errors():          Clears any errors and optionally flashes the status LED.
        set_absolute_position(): Sets the motor to an absolute position.
        set_position():          Sets the desired position for the motor.
        set_velocity():          Sets the desired velocity for the motor.
        set_torque():            Sets the desired torque for the motor.
        process_can_message():   Processes incoming CAN messages and updates the object's state.
        recv_all():              Asynchronously receives all messages from the CAN bus.
        save_data():             Asynchronously saves data to the database.
        get_velocity():          Returns the current velocity of the motor.
        run():                   Starts the main event loop for the class.
        
    Example Usage:
        # Create an instance of the ODriveCAN class (by default axis_state_name is closed_loop_control)
        odrive = ODriveCAN(nodeID=0x01)

        # Initialize CAN bus
        odrive.initCanBus()

        #Set O-Drive to position control
        odrive.set_controller_mode("position_control")

        # Set motor to a specific position
        odrive.set_position(100.0)

        #Set O-Drive to velocity control
        odrive.set_controller_mode("velocity_control")

        # Set motor velocity
        odrive.set_velocity(1.0)
        
        #Set O-Drive to torque control
        odrive.set_controller_mode("torque_control")

        # Set motor torque
        odrive.set_torque(0.1)

        # Issue an emergency stop command
        odrive.estop()

        # Clear errors on the O-Drive
        odrive.clear_errors()

        # Set the motor to an absolute position for the new default encoder "zero" postion to the current position.
        odrive.set_absolute_position()

        # Start the asynchronous event loop
        odrive.run()
    """
    def __init__(
            self,
            nodeID,
            canBusID="can0",
            canBusType="socketcan",
            position=None,
            velocity=None,
            torque_target=None,
            torque_estimate=None,
            bus_voltage=None,
            bus_current=None,
            iq_setpoint=None,
            iq_measured=None,
            electrical_power=None,
            mechanical_power=None,
            error_messages = None,
            database='odrive_data.db',
            axis_state_name = "closed_loop_control"):
    
        self.canBusID = canBusID
        self.canBusType = canBusType
        self.nodeID = nodeID
        self.canBus = can.interface.Bus(canBusID, bustype=canBusType)
        self.database = OdriveDatabase(database)
        self.collected_data = []  # Initialize an empty list to store data
        self.start_time = time.time()  # Capture the start time when the object is initialized
        self.latest_data = {}
        self.running = True
        #O-Drive Data
        self.position = position
        self.velocity = velocity
        self.torque_target = torque_target
        self.torque_estimate = torque_estimate
        self.bus_voltage = bus_voltage
        self.bus_current = bus_current
        self.iq_setpoint = iq_setpoint
        self.iq_measured = iq_measured
        self.electrical_power = electrical_power
        self.mechanical_power = mechanical_power
        self.error_messages = error_messages
        self.axis_state_name = axis_state_name
    
    def initCanBus(self):
        """
        Initalize connection to CAN Bus

        canBusID (String): Default "can0" this is the name of the can interface
        canBus (String): Default "socketcan" this is the python can libary CAN type
        """
         # Create and assign the CAN bus interface object to self.canBus
        self.canBus = can.interface.Bus(self.canBusID, bustype=self.canBusType)

        # Flush the CAN Bus of any previous messages
        self.flush_can_buffer()
        self.setAxisState()
        

    def flush_can_buffer(self):
        """
        Flushes the CAN receive buffer to clear any pending messages.

        Example:
            >>> odrive_can.flush_can_buffer()
            ...
            ... I have cleared all CAN Messages on the BUS!
        """
        #Flush CAN RX buffer to ensure no old pending messages.
        while not (self.canBus.recv(timeout=0) is None): pass
        print("I have cleared all CAN Messages on the BUS!")


    #Shutdown can bus at the end of a program. 
    def bus_shutdown(self):
        """
        Run this method at the end of your program to shundown the can bus to prevent can errors.

        Example:
        >>> import pyodrivecan
        >>> odrivecan.bus_shutdown()
        ...
        ... Can bus successfully shut down.
        """

        self.canBus.shutdown

        print("Can bus successfully shut down.")


#-------------------------------------- Set Axis State ------------------------------------------------
    def setAxisState(self):
        """
        Sets the Axis State of an ODrive Controller through CAN Bus using a human-readable state name.
        After sending the set state command, it listens for a heartbeat message to confirm the state change.

        Parameters:
            axis_state_name (str): The desired state to set for the axis, specified as a text string corresponding to the state names.

        Supported Axis States:
            - "undefined"
            - "idle"
            - "startup_sequence"
            - "full_calibration_sequence"
            - "motor_calibration"
            - "encoder_index_search"
            - "encoder_offset_calibration"
            - "closed_loop_control"
            - "lockin_spin"
            - "encoder_dir_find"
            - "Homing"
            - "encoder_hall_polarity_calibration"
            - "encoder_hall_phase_calibration"
            - "anticogging_calibration"

        Example:
            # Set the ODrive axis to Closed Loop Control
            >>> odrive_can.setAxisState("closed_loop_control")
        """
        # Mapping from state names to their corresponding codes
        state_codes = {
            "undefined": 0x0,
            "idle": 0x1,
            "startup_sequence": 0x2,
            "full_calibration_sequence": 0x3,
            "motor_calibration": 0x4,
            "encoder_index_search": 0x6,
            "encoder_offset_calibration": 0x7,
            "closed_loop_control": 0x8,
            "lockin_spin": 0x9,
            "encoder_dir_find": 0xA,
            "homing": 0xB,
            "encoder_hall_polarity_calibration": 0xC,
            "encoder_hall_phase_calibration": 0xD,
            "anticogging_calibration": 0xE,
        }

        # Reverse mapping from codes to state names for reporting purposes
        state_names = {code: name for name, code in state_codes.items()}

        if self.axis_state_name not in state_codes:
            print(f"Unsupported axis state: {self.axis_state_name}. Please check the state name.")
            return

        axis_requested_state = state_codes[self.axis_state_name]

        try:
            self.flush_can_buffer() #Flush all current can bus messages
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x07),  # 0x07: Set_Axis_State command ID
                data=struct.pack('<B', axis_requested_state),
                is_extended_id=False
            ))
            print(f"Axis state set command sent for {self.axis_state_name} ({axis_requested_state}) to ODrive {self.nodeID}.")
            
            # Now we wait for a heartbeat message to confirm the new state
            print(f"Waiting for confirmation from ODrive {self.nodeID}...")
            start_time = time.time()
            while time.time() - start_time < 5:  # Wait for up to 5 seconds for confirmation
                msg = self.canBus.recv(timeout=0.5)  # Adjust timeout as needed
                if msg and (msg.arbitration_id == (self.nodeID << 5 | 0x01)):  # 0x01: Heartbeat
                    _, state, _, _ = struct.unpack('<IBBB', bytes(msg.data[:7]))
                    if state == axis_requested_state:
                        print(f"Confirmation received: ODrive {self.nodeID} is now in state {self.axis_state_name}.")
                        return
                    else:
                        # Retrieve the actual state name from the code
                        actual_state_name = state_names.get(state, "Unknown State")
                        print(f"ODrive {self.nodeID} did not enter {self.axis_state_name}. It is currently in {actual_state_name}.")
                        return
                elif msg:
                    continue # Skip any non-heartbeat messages
                else:
                    # If no message is received within the timeout, print an error message
                    print(f"No confirmation received from ODrive {self.nodeID}. Please check the device.")
                    return

        except Exception as e:
            print(f"Error setting axis state for ODrive {self.nodeID}: {str(e)}")


#----------------------------------------- Set Controller Mode --------------------------------------------------------

    def set_controller_mode(self, control_mode_name, input_mode_name="pass_through"):
            """
            Sets the control mode and input mode of the ODrive controller using descriptive names.

            Control Modes:
                - "voltage_control": Direct voltage control.
                - "torque_control": Torque control mode.
                - "velocity_control": Velocity control mode.
                - "position_control": Position control mode.

            Input Modes:
                - "inactive": No input, motor remains idle.
                - "pass_through": Directly pass the setpoint to the control mode.
                - "vel_ramp": Ramp the velocity setpoint over time.
                - "pos_filter": Filter the position setpoint.
                - "mix_channels": Mix multiple control inputs.
                - "trap_traj": Trapezoidal trajectory control.
                - "torque_ramp": Ramp the torque setpoint over time.
                - "mirror": Mirror the control from another axis.
                - "tuning": Input mode for controller tuning.

            Parameters:
                control_mode_name (str): The control mode to set on the ODrive, specified by name.
                input_mode_name (str): The input mode to set on the ODrive, specified by name. Default is "pass_through".

            Example:
                # Set the ODrive to use torque control and passthrough input is set by default
                >>> odrive_can.set_controller_mode(control_mode_name="torque_control")
                ...
                ... Controller mode set to torque_control and input mode set to pass_through for ODrive #nodeID.

                # Set the ODrive to use velocity control and velocity ramp input
                >>> odrive_can.set_controller_mode(control_mode_name="velocity_control", input_mode_name="vel_ramp")
                ...
                ... Controller mode set to velocity_control and input mode set to vel_ramp for ODrive #nodeID.
            """
            # Mapping of control mode names to their corresponding codes
            control_modes = {
                "voltage_control": 0x00,
                "torque_control": 0x01,
                "velocity_control": 0x02,
                "position_control": 0x03
            }

            # Mapping of input mode names to their corresponding codes
            input_modes = {
                "inactive": 0x00,
                "pass_through": 0x01,
                "vel_ramp": 0x02,
                "pos_filter": 0x03,
                "mix_channels": 0x04,
                "trap_traj": 0x05,
                "torque_ramp": 0x06,
                "mirror": 0x07,
                "tuning": 0x08
            }

            # Translate names to codes
            control_mode = control_modes.get(control_mode_name.lower())
            input_mode = input_modes.get(input_mode_name.lower())

            if control_mode is None or input_mode is None:
                print(f"Invalid control_mode_name '{control_mode_name}' or input_mode_name '{input_mode_name}'.")
                return

            try:
                # Construct the data payload by packing the control_mode and input_mode into bytes
                data_payload = struct.pack('<II', control_mode, input_mode)

                # Send the CAN message
                self.canBus.send(can.Message(
                    arbitration_id=(self.nodeID << 5 | 0x0b),  # 0x0b: Set_Controller_Mode command ID
                    data=data_payload,
                    is_extended_id=False
                ))
                print(f"Controller mode set to {control_mode_name} and input mode set to {input_mode_name} for ODrive {self.nodeID}.")
            except Exception as e:
                print(f"Error sending Set_Controller_Mode command to ODrive {self.nodeID}: {str(e)}")


#-------------------------------------- E-Stop ------------------------------------------------
    def estop(self):
        """
        Triggers an emergency stop on the ODrive motor. This command disarms the axis and sets its state to ESTOP_REQUESTED.

        Example:
            >>> odrive_can.estop()
            ...
            ... Estop requested for ODrive #NodeID.
        """
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x02),  # 0x02: Estop Command ID
                data=b'',  # Empty payload as specified
                is_extended_id=False
            ))
            print(f"Estop requested for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending Estop command to ODrive {self.nodeID}: {str(e)}")



#-------------------------------------- Clear Errors ------------------------------------------------
    def clear_errors(self, identify=True):
        """
        Sends a command to the ODrive to clear errors and optionally flash the status LED for identification.

        Parameters:
            identify (bool): If True, the status LED will flash to help identify the ODrive device. This is useful in a setup with multiple devices.

        Example:
            # Clear errors and flash the LED to identify the ODrive
            >>> odrive_can.clear_errors()
            ... 
            ... Cleared errors for ODrive NodeID. LED flash is enabled.
            
            # Clear errors without flashing the LED and flash the LED to identify the ODrive
            >>> odrive_can.clear_errors(identify=False)
            ...
            ... Cleared errors for ODrive NodeID. LED flash is disabled.

        Note: The LED flash helps to physically identify which ODrive is being addressed in a multi-device setup.
        """
        identify_byte = 0x01 if identify else 0x00
        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x18),  # 0x18: Clear_Errors Command ID
                data=struct.pack('<B', identify_byte),
                is_extended_id=False
            ))
            print(f"Cleared errors for ODrive {self.nodeID}. LED flash is {'enabled' if identify else 'disabled'}.")
        except Exception as e:
            print(f"Error sending Clear_Errors command to ODrive {self.nodeID}: {str(e)}")



#-------------------------------------- Set Absoulte Postion  ------------------------------------------------
    def set_absolute_position(self, position=None):
        """
        Sends a command to the ODrive to set the motor to an absolute position. If no position is specified,
        the motor will be set to the last known position.

        Parameters:
            position (float, optional): The new position for the motor in revolutions. If None, the last known position will be used.

        Example:
            # Set the motor to an absolute position of 10 revolutions
            >>> odrive_can.set_absolute_position(10.0)

            # Set the motor to the last known position
            >>> odrive_can.set_absolute_position()
        """
        # Use the latest known position if none is provided
        if position is None:
            position = self.position
            if position is None:
                print("No position specified and no known last position. Command aborted.")
                return

        try:
            self.canBus.send(can.Message(
                arbitration_id=(self.nodeID << 5 | 0x19),  # 0x19: Set_Absolute_Position Command ID
                data=struct.pack('<f', position),  # Pack the position as a float32
                is_extended_id=False
            ))
            print(f"Set absolute position to {position} revolutions for ODrive {self.nodeID}.")
        except Exception as e:
            print(f"Error sending Set_Absolute_Position command to ODrive {self.nodeID}: {str(e)}")




#-------------------------------------- Motor Controls START------------------------------------------------
    # Function to set position for a specific O-Drive
    def set_position(self, position, velocity_feedforward=0, torque_feedforward=0):
        """
        Sets the position of the ODrive motor.

        Para:
            position (float): Target position for the motor.
            velocity_feedforward (float): Feedforward velocity, default is 0.
            torque_feedforward (float): Feedforward torque, default is 0.

        Example:
            >>> odrive_can.set_position(1000.0)
        """

        self.canBus.send(can.Message(
            arbitration_id=(self.nodeID << 5 | 0x0C),
            data=struct.pack('<fhh', float(position), velocity_feedforward, torque_feedforward),
            is_extended_id=False
        ))
        #print(f"Successfully moved ODrive {self.nodeID} to {position}")
        

    # Function to set velocity for a specific O-Drive
    def set_velocity(self, velocity, torque_feedforward=0.0):
        """
        Sets the velocity of the ODrive motor.

        Para:
            velocity (float): Target velocity for the motor.
            torque_feedforward (float): Feedforward torque, default is 0.

        Example:
            >>> odrive_can.set_velocity(500.0)
        """

        self.canBus.send(can.Message(
            arbitration_id=(self.nodeID << 5 | 0x0d),  # 0x0d: Set_Input_Vel
            data=struct.pack('<ff', velocity, torque_feedforward),
            is_extended_id=False
        ))


    # Function to set torque for a specific O-Drive
    def set_torque(self, torque):
        """
        Sets the torque of the ODrive motor.

        Para:
            torque (float): Target torque for the motor.

        Example:
            >>> odrive_can.set_torque(10.0)
        """
        
        self.canBus.send(can.Message(
            arbitration_id=(self.nodeID << 5 | 0x0E),  # 0x0E: Set_Input_Torque
            data=struct.pack('<f', torque),
            is_extended_id=False
        ))
        #print(f"Successfully set ODrive {self.nodeID} to {torque} [Nm]")
#-------------------------------------- Motor Controls END-------------------------------------------------




#-------------------------------------- Motor Feedback ----------------------------------------------------
# In order for these functions to work you need to have the O-Drive set with the Cyclic messages 
# The cyclic messgaes for CAN will make the O-Drive automatically send the data you want to collect at the set rate.


    ERROR_CODES = {
        0x00: "NONE",
        0x01: "INITIALIZING",
        0x02: "SYSTEM_LEVEL",
        0x04: "TIMING_ERROR",
        0x08: "MISSING_ESTIMATE",
        0x10: "BAD_CONFIG",
        0x20: "DRV_FAULT",
        0x40: "MISSING_INPUT",
        0x80: "SPINOUT_DETECTED",
        0x100: "DC_BUS_OVER_VOLTAGE",
        0x200: "DC_BUS_UNDER_VOLTAGE",
        0x400: "DC_BUS_OVER_CURRENT",
        0x800: "DC_BUS_OVER_REGEN_CURRENT",
        0x1000: "CURRENT_LIMIT_VIOLATION",
        0x2000: "MOTOR_OVER_TEMP",
        0x4000: "INVERTER_OVER_TEMP",
        0x8000: "VELOCITY_LIMIT_VIOLATION",
        0x10000: "POSITION_LIMIT_VIOLATION",
        0x2000000: "ESTOP_REQUESTED",
        0x4000000: "SPINOUT_DETECTED",
        0x8000000: "BRAKE_RESISTOR_DISARMED",
        0x10000000: "THERMISTOR_DISCONNECTED",
        0x40000000: "CALIBRATION_ERROR",
        0x1000000: "WATCHDOG_TIMER_EXPIRED"
    }
        

    def process_can_message(self, message):
        """
        Processes received CAN messages and updates the latest data.
        """
        
        arbitration_id = message.arbitration_id
        data = message.data
        if arbitration_id == (self.nodeID << 5 | 0x09):  # Encoder estimate
            position, velocity = struct.unpack('<ff', data)
            self.position = position
            self.velocity = velocity
            #print(f"Encoder Estimate - Position: {position:.3f} turns, Velocity: {velocity:.3f} turns/s")
        elif arbitration_id == (self.nodeID << 5 | 0x1C):  # Torque
            torque_target, torque_estimate = struct.unpack('<ff', data)
            self.torque_target = torque_target
            self.torque_estimate = torque_estimate
            #print(f"Torque - Target: {torque_target:.3f} Nm, Estimate: {torque_estimate:.3f} Nm")
        elif arbitration_id == (self.nodeID << 5 | 0x17):  # Bus voltage and current
            bus_voltage, bus_current = struct.unpack('<ff', data)
            self.bus_voltage = bus_voltage
            self.bus_current = bus_current
            #print(f"Bus Voltage and Current - Voltage: {bus_voltage:.3f} V, Current: {bus_current:.3f} A")
        elif arbitration_id == (self.nodeID << 5 | 0x14):  # IQ setpoint and measured
            iq_setpoint, iq_measured = struct.unpack('<ff', data)
            self.iq_setpoint = iq_setpoint
            self.iq_measured = iq_measured
            #print(f"IQ Setpoint and Measured - Setpoint: {iq_setpoint:.3f} A, Measured: {iq_measured:.3f} A")
        elif arbitration_id == (self.nodeID << 5 | 0x1D):  # Powers
            electrical_power, mechanical_power = struct.unpack('<ff', data)
            self.electrical_power = electrical_power
            self.mechanical_power = mechanical_power
            #print(f"Powers - Electrical: {electrical_power:.3f} W, Mechanical: {mechanical_power:.3f} W")
        elif arbitration_id == (self.nodeID << 5 | 0x03):  # Get_Error message
            active_errors, disarm_reason = struct.unpack('<II', data)
            # Decode and print active errors
            if active_errors != 0:  # Check if there are any active errors
                errors = [description for code, description in self.ERROR_CODES.items() if active_errors & code]
                error_messages = ', '.join(errors)
                print(f"ODrive {self.nodeID} Active Errors: {error_messages}")
            else:
                print(f"ODrive {self.nodeID} No active errors.")
            
            # Decode and print disarm reason
            if disarm_reason != 0:  # Check if there is a disarm reason
                reasons = [description for code, description in self.ERROR_CODES.items() if disarm_reason & code]
                reason_messages = ', '.join(reasons)
                print(f"ODrive {self.nodeID} Disarm Reason: {reason_messages}")
            else:
                print(f"ODrive {self.nodeID} No disarm reason.")


    #This is aysnc receiving the messages from the can bus and feeding them into the process_can_message method.
    async def recv_all(self):
        while self.running:
            await asyncio.sleep(0)
            msg = self.canBus.recv(timeout=0)
            if msg is not None:
                self.process_can_message(msg)


    
    #This is aysnc saving the data to a database at a set rate (timeout=0.1) every 0.1 seconds.
    async def save_data(self, timeout=0.1):
        # Fetch the next trial_id
        next_trial_id = self.database.get_next_trial_id()
        print(f"Using trial_id: {next_trial_id}")
        node_id = self.nodeID
        while self.running:
            await asyncio.sleep(timeout)
            # Calculate elapsed time since the start of the program
            current_time = time.time() - self.start_time
            self.database.add_odrive_data(
                next_trial_id,
                node_id,
                current_time,
                self.position,
                self.velocity,
                self.torque_target,
                self.torque_estimate,
                self.bus_voltage,
                self.bus_current,
                self.iq_setpoint,
                self.iq_measured,
                self.electrical_power,
                self.mechanical_power
            )


    async def get_velocity(self):
        """
        This function makes sure that the returned velocity is not 'None'
        """
        while self.running and self.velocity is None:
            await asyncio.sleep(0)
        return self.velocity

    #This is the async loop that runs the receve_msgs and save_data methods async.
    async def loop(self, *others):
        await asyncio.gather(
            self.recv_all(),
            self.save_data(),
            *others,
        )

    def run(self, *others):
        asyncio.run(self.loop(*others))
